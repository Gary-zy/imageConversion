{
  "version": 3,
  "sources": ["../../@lapo/asn1js/hex.js"],
  "sourcesContent": ["// Hex JavaScript decoder\n// Copyright (c) 2008 Lapo Luchini <lapo@lapo.it>\n\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\nconst\n    haveU8 = (typeof Uint8Array == 'function');\n\nlet decoder; // populated on first usage\n\nexport class Hex {\n\n    /**\n     * Decodes an hexadecimal value.\n     * @param {string|Array|Uint8Array} a - a string representing hexadecimal data, or an array representation of its charcodes\n     */\n    static decode(a) {\n        let isString = (typeof a == 'string');\n        let i;\n        if (decoder === undefined) {\n            let hex = '0123456789ABCDEF',\n                ignore = ' \\f\\n\\r\\t\\u00A0\\u2028\\u2029';\n            decoder = [];\n            for (i = 0; i < 16; ++i)\n                decoder[hex.charCodeAt(i)] = i;\n            hex = hex.toLowerCase();\n            for (i = 10; i < 16; ++i)\n                decoder[hex.charCodeAt(i)] = i;\n            for (i = 0; i < ignore.length; ++i)\n                decoder[ignore.charCodeAt(i)] = -1;\n        }\n        let out = haveU8 ? new Uint8Array(a.length >> 1) : [],\n            bits = 0,\n            char_count = 0,\n            len = 0;\n        for (i = 0; i < a.length; ++i) {\n            let c = isString ? a.charCodeAt(i) : a[i];\n            c = decoder[c];\n            if (c == -1)\n                continue;\n            if (c === undefined)\n                throw 'Illegal character at offset ' + i;\n            bits |= c;\n            if (++char_count >= 2) {\n                out[len++] = bits;\n                bits = 0;\n                char_count = 0;\n            } else {\n                bits <<= 4;\n            }\n        }\n        if (char_count)\n            throw 'Hex encoding incomplete: 4 bits missing';\n        if (haveU8 && out.length > len) // in case it was originally longer because of ignored characters\n            out = out.subarray(0, len);\n        return out;\n    }\n\n}\n"],
  "mappings": ";;;AAeA,IACI,SAAU,OAAO,cAAc;AAEnC,IAAI;AAEG,IAAM,MAAN,MAAU;AAAA;AAAA;AAAA;AAAA;AAAA,EAMb,OAAO,OAAO,GAAG;AACb,QAAI,WAAY,OAAO,KAAK;AAC5B,QAAI;AACJ,QAAI,YAAY,QAAW;AACvB,UAAI,MAAM,oBACN,SAAS;AACb,gBAAU,CAAC;AACX,WAAK,IAAI,GAAG,IAAI,IAAI,EAAE;AAClB,gBAAQ,IAAI,WAAW,CAAC,CAAC,IAAI;AACjC,YAAM,IAAI,YAAY;AACtB,WAAK,IAAI,IAAI,IAAI,IAAI,EAAE;AACnB,gBAAQ,IAAI,WAAW,CAAC,CAAC,IAAI;AACjC,WAAK,IAAI,GAAG,IAAI,OAAO,QAAQ,EAAE;AAC7B,gBAAQ,OAAO,WAAW,CAAC,CAAC,IAAI;AAAA,IACxC;AACA,QAAI,MAAM,SAAS,IAAI,WAAW,EAAE,UAAU,CAAC,IAAI,CAAC,GAChD,OAAO,GACP,aAAa,GACb,MAAM;AACV,SAAK,IAAI,GAAG,IAAI,EAAE,QAAQ,EAAE,GAAG;AAC3B,UAAI,IAAI,WAAW,EAAE,WAAW,CAAC,IAAI,EAAE,CAAC;AACxC,UAAI,QAAQ,CAAC;AACb,UAAI,KAAK;AACL;AACJ,UAAI,MAAM;AACN,cAAM,iCAAiC;AAC3C,cAAQ;AACR,UAAI,EAAE,cAAc,GAAG;AACnB,YAAI,KAAK,IAAI;AACb,eAAO;AACP,qBAAa;AAAA,MACjB,OAAO;AACH,iBAAS;AAAA,MACb;AAAA,IACJ;AACA,QAAI;AACA,YAAM;AACV,QAAI,UAAU,IAAI,SAAS;AACvB,YAAM,IAAI,SAAS,GAAG,GAAG;AAC7B,WAAO;AAAA,EACX;AAEJ;",
  "names": []
}
