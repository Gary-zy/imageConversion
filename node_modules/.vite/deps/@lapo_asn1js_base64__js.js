import "./chunk-KEXKKQVW.js";

// node_modules/@lapo/asn1js/base64.js
var haveU8 = typeof Uint8Array == "function";
var decoder;
var Base64 = class _Base64 {
  static decode(a) {
    let isString = typeof a == "string";
    let i;
    if (decoder === void 0) {
      let b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ignore = "= \f\n\r	Â \u2028\u2029";
      decoder = [];
      for (i = 0; i < 64; ++i)
        decoder[b64.charCodeAt(i)] = i;
      for (i = 0; i < ignore.length; ++i)
        decoder[ignore.charCodeAt(i)] = -1;
      decoder["-".charCodeAt(0)] = decoder["+".charCodeAt(0)];
      decoder["_".charCodeAt(0)] = decoder["/".charCodeAt(0)];
    }
    let out = haveU8 ? new Uint8Array(a.length * 3 >> 2) : [];
    let bits = 0, char_count = 0, len = 0;
    for (i = 0; i < a.length; ++i) {
      let c = isString ? a.charCodeAt(i) : a[i];
      if (c == 61)
        break;
      c = decoder[c];
      if (c == -1)
        continue;
      if (c === void 0)
        throw "Illegal character at offset " + i;
      bits |= c;
      if (++char_count >= 4) {
        out[len++] = bits >> 16;
        out[len++] = bits >> 8 & 255;
        out[len++] = bits & 255;
        bits = 0;
        char_count = 0;
      } else {
        bits <<= 6;
      }
    }
    switch (char_count) {
      case 1:
        throw "Base64 encoding incomplete: at least 2 bits missing";
      case 2:
        out[len++] = bits >> 10;
        break;
      case 3:
        out[len++] = bits >> 16;
        out[len++] = bits >> 8 & 255;
        break;
    }
    if (haveU8 && out.length > len)
      out = out.subarray(0, len);
    return out;
  }
  static pretty(str) {
    let pad = 4 - str.length % 4;
    if (pad < 4)
      str += "===".slice(0, pad);
    str = str.replace(/-/g, "+").replace(/_/g, "/");
    return str.replace(/.{80}/g, "$&\n");
  }
  static unarmor(a) {
    let m = _Base64.re.exec(a);
    if (m) {
      if (m[1])
        a = m[1];
      else if (m[2])
        a = m[2];
      else if (m[3])
        a = m[3];
      else
        throw "RegExp out of sync";
    }
    return _Base64.decode(a);
  }
};
Base64.re = /-----BEGIN [^-]+-----([A-Za-z0-9+/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+/=\s]+)====|^([A-Za-z0-9+/=\s]+)$/;
export {
  Base64
};
//# sourceMappingURL=@lapo_asn1js_base64__js.js.map
