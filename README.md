# å›¾ç‰‡è½¬æ¢å™¨ - å¤šåŠŸèƒ½åœ¨çº¿å›¾ç‰‡/OFDæ–‡æ¡£å¤„ç†å·¥å…·

[English](./README_EN.md) | ç®€ä½“ä¸­æ–‡

ğŸ”— **åœ¨çº¿é¢„è§ˆ**: [https://gary-zy.github.io/imageConversion/](https://gary-zy.github.io/imageConversion/)

å…è´¹åœ¨çº¿å›¾ç‰‡æ ¼å¼è½¬æ¢å·¥å…·ï¼Œæ”¯æŒå¤šç§å›¾ç‰‡æ ¼å¼äº’è½¬ã€OFDæ–‡æ¡£å¤„ç†ã€‚æ‰€æœ‰è½¬æ¢åœ¨æµè§ˆå™¨æœ¬åœ°å®Œæˆï¼Œä¿æŠ¤éšç§ï¼Œæ— éœ€ä¸Šä¼ æœåŠ¡å™¨ã€‚

[![License](https://img.shields.io/badge/license-MIT-blue.svg)](./LICENSE)
[![Vue](https://img.shields.io/badge/Vue-3.4-42b883.svg)](https://vuejs.org/)
[![TypeScript](https://img.shields.io/badge/TypeScript-5.6-3178c6.svg)](https://www.typescriptlang.org/)
[![Vite](https://img.shields.io/badge/Vite-6-646cff.svg)](https://vitejs.dev/)
[![GitHub Pages](https://img.shields.io/badge/Demo-GitHub%20Pages-brightgreen)](https://gary-zy.github.io/imageConversion/)

## ç›®å½•

- [åŠŸèƒ½ç‰¹æ€§](#åŠŸèƒ½ç‰¹æ€§)
- [æŠ€æœ¯æ¶æ„](#æŠ€æœ¯æ¶æ„)
- [æ ¸å¿ƒåŠŸèƒ½å®ç°](#æ ¸å¿ƒåŠŸèƒ½å®ç°)
  - [å›¾ç‰‡è½¬æ¢å®ç°](#å›¾ç‰‡è½¬æ¢å®ç°)
  - [OFDæ–‡æ¡£å¤„ç†å®ç°](#ofdæ–‡æ¡£å¤„ç†å®ç°)
- [é¡¹ç›®ç»“æ„](#é¡¹ç›®ç»“æ„)
- [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
- [éƒ¨ç½²æ–¹æ¡ˆ](#éƒ¨ç½²æ–¹æ¡ˆ)

---

## åŠŸèƒ½ç‰¹æ€§

### å›¾ç‰‡æ ¼å¼è½¬æ¢

| åˆ†ç±» | æ”¯æŒæ ¼å¼ |
|------|----------|
| **å¸¸ç”¨æ ¼å¼** | JPEGã€PNGã€WebPã€AVIFã€GIFã€BMPã€TIFF |
| **ä¸“ä¸šæ ¼å¼** | PSDã€EXRã€HDRã€DDSã€XPM |
| **å›¾æ ‡æ ¼å¼** | ICOï¼ˆå¤šå°ºå¯¸ï¼‰ã€ICNSï¼ˆmacOSï¼‰ã€CURï¼ˆWindows å…‰æ ‡ï¼‰ |
| **æ–‡æ¡£æ ¼å¼** | PDF |
| **ä¾¿æºæ ¼å¼** | PBMã€PGMã€PPMã€XBMã€WBMP |
| **ç°ä»£æ ¼å¼** | QOIã€JP2ã€PCXã€SVG |

### å›¾ç‰‡ç¼–è¾‘åŠŸèƒ½

- **åŸºç¡€è°ƒæ•´**: å°ºå¯¸è°ƒæ•´ï¼ˆæ”¯æŒå®½é«˜æ¯”ï¼‰ã€æ—‹è½¬ã€ç¿»è½¬ã€è£å‰ª
- **å›¾åƒå¢å¼º**: äº®åº¦ã€å¯¹æ¯”åº¦ã€é¥±å’Œåº¦è°ƒèŠ‚
- **æ»¤é•œæ•ˆæœ**: æ¨¡ç³Šã€é”åŒ–ã€ç°åº¦ã€å¤å¤ã€åè‰²
- **æ°´å°åŠŸèƒ½**: æ–‡å­—æ°´å°ã€å›¾ç‰‡æ°´å°ï¼Œæ”¯æŒå¹³é“ºã€å¯¹è§’çº¿ã€å…¨é¡µç­‰å¤šç§æ ·å¼
- **èƒŒæ™¯å¤„ç†**: æ”¯æŒè‡ªå®šä¹‰èƒŒæ™¯è‰²

### OFD æ–‡æ¡£å¤„ç†

- **OFD è½¬å›¾ç‰‡**: å°† OFD æ–‡æ¡£è½¬æ¢ä¸º PNG/JPEG/WebP æ ¼å¼
- **OFD è½¬ PDF**: å°† OFD æ–‡æ¡£å¯¼å‡ºä¸º PDF æ–‡ä»¶
- **é¡µé¢é€‰æ‹©**: æ”¯æŒå…¨éƒ¨é¡µé¢ã€å½“å‰é¡µé¢ã€è‡ªå®šä¹‰é¡µç èŒƒå›´
- **ç”µå­ç­¾ç« éªŒè¯**: æ”¯æŒå›½å¯† SM2 ç®—æ³•ç­¾ç« éªŒè¯
- **ç­¾ç« ä¿¡æ¯æŸ¥çœ‹**: æŸ¥çœ‹ç­¾ç« è¯ä¹¦ä¿¡æ¯ã€ç­¾åæ—¶é—´ç­‰è¯¦æƒ…

### å…¶ä»–ç‰¹æ€§

- **æ‰¹é‡å¤„ç†**: æ”¯æŒæ‰¹é‡ä¸Šä¼ å’Œæ‰¹é‡è½¬æ¢
- **ZIP æ‰“åŒ…**: æ‰¹é‡ä¸‹è½½æ—¶è‡ªåŠ¨æ‰“åŒ…ä¸º ZIP æ–‡ä»¶
- **æ‹–æ‹½ä¸Šä¼ **: æ”¯æŒæ‹–æ‹½ã€ç‚¹å‡»æˆ– Ctrl+V ç²˜è´´ä¸Šä¼ 
- **å“åº”å¼è®¾è®¡**: å®Œç¾æ”¯æŒæ¡Œé¢ç«¯å’Œç§»åŠ¨ç«¯
- **PWA æ”¯æŒ**: å¯å®‰è£…ä¸ºæœ¬åœ°åº”ç”¨ï¼Œç¦»çº¿ä½¿ç”¨
- **éšç§ä¿æŠ¤**: æ‰€æœ‰å¤„ç†åœ¨æµè§ˆå™¨æœ¬åœ°å®Œæˆï¼Œä¸ä¸Šä¼ æ–‡ä»¶

---

## æŠ€æœ¯æ¶æ„

### æŠ€æœ¯æ ˆ

| é¢†åŸŸ | æŠ€æœ¯ |
|------|------|
| **UI æ¡†æ¶** | Vue 3.4 (Composition API + `<script setup>`) |
| **æ„å»ºå·¥å…·** | Vite 6 |
| **è¯­è¨€** | TypeScript 5.6 |
| **æ ·å¼æ–¹æ¡ˆ** | Tailwind CSS 3.4 |
| **çŠ¶æ€ç®¡ç†** | Vue 3 Reactive (æ›¿ä»£ Zustand) |
| **å›¾ç‰‡å¤„ç†** | Canvas APIã€Picaï¼ˆé«˜è´¨é‡ç¼©æ”¾ï¼‰ |
| **PDF ç”Ÿæˆ** | jsPDF |
| **OFD è§£æ** | ofd.jsï¼ˆè‡ªå®šä¹‰å®ç°ï¼‰ |
| **å›½å¯†ç®—æ³•** | sm-cryptoï¼ˆSM2/SM3/SM4ï¼‰ã€jsrsasign |
| **å›¾æ ‡å¤„ç†** | psd.jsã€utif |
| **æ–‡ä»¶å¤„ç†** | JSZipã€file-saver |

### æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        åº”ç”¨å±‚ (Vue 3)                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ FileUpload  â”‚  â”‚  FormatSel  â”‚  â”‚     ImagePreview        â”‚  â”‚
â”‚  â”‚   ç»„ä»¶      â”‚  â”‚   ç»„ä»¶      â”‚  â”‚       ç»„ä»¶              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  FileList   â”‚  â”‚ OfdProcessorâ”‚  â”‚    OfdPreview           â”‚  â”‚
â”‚  â”‚   ç»„ä»¶      â”‚  â”‚   ç»„ä»¶      â”‚  â”‚       ç»„ä»¶              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      çŠ¶æ€å±‚ (Reactive Store)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                   useImageStore                           â”‚   â”‚
â”‚  â”‚  files | targetFormat | settings | isConverting          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      å·¥å…·å±‚ (Utils)                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ imageConv   â”‚  â”‚ ofdConverterâ”‚  â”‚      download           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      æµè§ˆå™¨åŸç”Ÿ API                              â”‚
â”‚  Canvas API | File API | Web Workers | IndexedDB                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### çŠ¶æ€ç®¡ç†è®¾è®¡

é¡¹ç›®ä½¿ç”¨ Vue 3 çš„ `reactive` + `computed` æ›¿ä»£ Zustandï¼š

```typescript
// stores/imageStore.ts
import { reactive, computed } from 'vue';

interface ImageFile {
  id: string;
  file: File;
  preview: string;
  convertedBlob?: Blob;
  status: 'pending' | 'converting' | 'completed' | 'failed';
  progress: number;
  error?: string;
}

interface Settings {
  quality: number;
  maxWidth: number;
  maxHeight: number;
  maintainAspectRatio: boolean;
  autoResize: boolean;
  backgroundColor: string;
  watermarkEnabled: boolean;
  watermarkText: string;
  watermarkPosition: 'center' | 'corner' | 'diagonal' | 'tile';
  fileNamePrefix: string;
  fileNameSuffix: string;
}

export const useImageStore = () => {
  const state = reactive({
    files: [] as ImageFile[],
    targetFormat: 'png' as ImageFormat,
    settings: {
      quality: 90,
      maxWidth: 0,
      maxHeight: 0,
      maintainAspectRatio: true,
      autoResize: false,
      backgroundColor: '#ffffff',
      watermarkEnabled: false,
      watermarkText: '',
      watermarkPosition: 'center' as const,
      fileNamePrefix: '',
      fileNameSuffix: '',
    } as Settings,
    isConverting: false,
  });

  return state;
};
```

---

## æ ¸å¿ƒåŠŸèƒ½å®ç°

### å›¾ç‰‡è½¬æ¢å®ç°

#### è½¬æ¢æµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ–‡ä»¶    â”‚ -> â”‚  è¯»å–    â”‚ -> â”‚ Canvas   â”‚ -> â”‚ æ ¼å¼ç¼–ç  â”‚ -> â”‚  ä¿å­˜    â”‚
â”‚  ä¸Šä¼     â”‚    â”‚  è§£ç     â”‚    â”‚  ç»˜åˆ¶    â”‚    â”‚  è¾“å‡º    â”‚    â”‚  ä¸‹è½½    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### æ ¸å¿ƒä»£ç å®ç°

**1. å›¾ç‰‡è¯»å–ä¸è§£ç **

```typescript
// utils/imageConverter.ts
export const readImageFile = async (file: File): Promise<HTMLImageElement> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = URL.createObjectURL(file);
  });
};

export const decodeImageData = async (
  data: ArrayBuffer
): Promise<ImageData> => {
  const bitmap = await createImageBitmap(new Blob([data]));
  const canvas = document.createElement('canvas');
  canvas.width = bitmap.width;
  canvas.height = bitmap.height;
  const ctx = canvas.getContext('2d');
  ctx?.drawImage(bitmap, 0, 0);
  return ctx!.getImageData(0, 0, bitmap.width, bitmap.height);
};
```

**2. Canvas ç»˜åˆ¶ä¸å¤„ç†**

```typescript
export const drawToCanvas = async (
  img: HTMLImageElement,
  canvas: HTMLCanvasElement,
  options: ConversionOptions
): Promise<void> => {
  const ctx = canvas.getContext('2d');
  if (!ctx) throw new Error('æ— æ³•è·å– Canvas ä¸Šä¸‹æ–‡');

  // è°ƒæ•´å°ºå¯¸
  const { width, height } = calculateTargetSize(
    img.width,
    img.height,
    options.maxWidth,
    options.maxHeight,
    options.maintainAspectRatio
  );

  canvas.width = width;
  canvas.height = height;

  // ç»˜åˆ¶èƒŒæ™¯
  if (options.backgroundColor) {
    ctx.fillStyle = options.backgroundColor;
    ctx.fillRect(0, 0, width, height);
  }

  // ä½¿ç”¨ Pica è¿›è¡Œé«˜è´¨é‡ç¼©æ”¾
  if (options.scale && options.scale !== 1) {
    const pica = window.pica();
    const srcCanvas = document.createElement('canvas');
    srcCanvas.width = img.width;
    srcCanvas.height = img.height;
    const srcCtx = srcCanvas.getContext('2d');
    srcCtx?.drawImage(img, 0, 0);
    await pica.resize(srcCanvas, canvas, {
      unsharpAmount: 80,
      unsharpRadius: 0.6,
      unsharpThreshold: 2,
    });
  } else {
    ctx.drawImage(img, 0, 0, width, height);
  }

  // åº”ç”¨æ°´å°
  if (options.watermarkEnabled && options.watermarkText) {
    drawWatermark(ctx, width, height, options.watermarkText, options.watermarkPosition);
  }
};

const calculateTargetSize = (
  srcWidth: number,
  srcHeight: number,
  maxWidth: number,
  maxHeight: number,
  maintainAspectRatio: boolean
): { width: number; height: number } => {
  if (!maxWidth && !maxHeight) {
    return { width: srcWidth, height: srcHeight };
  }

  let width = srcWidth;
  let height = srcHeight;

  if (maxWidth && width > maxWidth) {
    width = maxWidth;
    if (maintainAspectRatio) {
      height = Math.round((width / srcWidth) * srcHeight);
    }
  }

  if (maxHeight && height > maxHeight) {
    height = maxHeight;
    if (maintainAspectRatio) {
      width = Math.round((height / srcHeight) * srcWidth);
    }
  }

  return { width, height };
};
```

**3. æ ¼å¼ç¼–ç ä¸è¾“å‡º**

```typescript
export const convertToBlob = async (
  canvas: HTMLCanvasElement,
  format: ImageFormat,
  quality: number
): Promise<Blob> => {
  const mimeType = getMimeType(format);
  return new Promise((resolve, reject) => {
    canvas.toBlob(
      (blob) => {
        if (blob) {
          resolve(blob);
        } else {
          reject(new Error('æ ¼å¼è½¬æ¢å¤±è´¥'));
        }
      },
      mimeType,
      quality / 100
    );
  });
};

const getMimeType = (format: ImageFormat): string => {
  const mimeTypes: Record<ImageFormat, string> = {
    jpeg: 'image/jpeg',
    png: 'image/png',
    webp: 'image/webp',
    gif: 'image/gif',
    bmp: 'image/bmp',
    tiff: 'image/tiff',
    avif: 'image/avif',
    ico: 'image/x-icon',
    pdf: 'application/pdf',
  };
  return mimeTypes[format] || 'image/png';
};
```

**4. æ‰¹é‡è½¬æ¢**

```typescript
export const convertAllImages = async (
  files: ImageFile[],
  format: ImageFormat,
  options: ConversionOptions,
  onProgress?: (current: number, total: number) => void
): Promise<void> => {
  for (let i = 0; i < files.length; i++) {
    const imageFile = files[i];
    try {
      imageFile.status = 'converting';
      imageFile.progress = 0;

      // è¯»å–å›¾ç‰‡
      const img = await readImageFile(imageFile.file);

      // åˆ›å»º Canvas
      const canvas = document.createElement('canvas');
      await drawToCanvas(img, canvas, options);

      // è½¬æ¢æ ¼å¼
      const blob = await convertToBlob(canvas, format, options.quality);

      imageFile.convertedBlob = blob;
      imageFile.status = 'completed';
      imageFile.progress = 100;

      onProgress?.(i + 1, files.length);
    } catch (error) {
      imageFile.status = 'failed';
      imageFile.error = error instanceof Error ? error.message : 'è½¬æ¢å¤±è´¥';
    }
  }
};
```

---

### OFDæ–‡æ¡£å¤„ç†å®ç°

#### OFD æ–‡ä»¶ç»“æ„

OFDï¼ˆOpen Fixed Layout Documentï¼‰æ˜¯ä¸€ç§å¼€æ”¾ç‰ˆå¼æ–‡æ¡£æ ¼å¼ï¼Œç±»ä¼¼ PDFã€‚å…¶æ–‡ä»¶ç»“æ„ï¼š

```
OFD æ–‡ä»¶ (ZIP å‹ç¼©åŒ…)
â”œâ”€â”€ Doc_0/
â”‚   â”œâ”€â”€ Document.xml          # æ–‡æ¡£ä¸»ç»“æ„
â”‚   â”œâ”€â”€ PublicRes.xml         # å…¬å…±èµ„æºç´¢å¼•
â”‚   â”œâ”€â”€ DocumentRes.xml       # æ–‡æ¡£èµ„æºç´¢å¼•
â”‚   â”œâ”€â”€ Pages/                # é¡µé¢ç›®å½•
â”‚   â”‚   â”œâ”€â”€ Page_0/
â”‚   â”‚   â”‚   â”œâ”€â”€ Content.xml   # é¡µé¢å†…å®¹
â”‚   â”‚   â”‚   â””â”€â”€ Res.xml       # é¡µé¢èµ„æº
â”‚   â”‚   â””â”€â”€ Page_1/
â”‚   â””â”€â”€ Res/                  # èµ„æºç›®å½•
â”‚       â”œâ”€â”€ Fonts/            # å­—ä½“èµ„æº
â”‚       â”œâ”€â”€ Images/           # å›¾ç‰‡èµ„æº
â”‚       â””â”€â”€ Symbols/          # ç¬¦å·èµ„æº
â””â”€â”€ OFD.xml                   # æ–‡æ¡£åŒ…æè¿°
```

#### OFD è§£æå™¨å®ç°

**1. ZIP è§£å‹ä¸ XML è§£æ**

```typescript
// utils/ofdConverter.ts
export class OfdConverter {
  private zipReader: any;
  private documentXml: Document | null = null;
  private pages: OFDPage[] = [];
  private resources: Map<string, any> = new Map();
  private currentPageIndex = 0;

  async loadOfd(
    file: File,
    onProgress?: (current: number, total: number, status: string) => void
  ): Promise<void> {
    onProgress?.(0, 10, 'æ­£åœ¨è§£å‹ OFD æ–‡ä»¶...');

    // è§£å‹ ZIP
    const zip = await JSZip.loadAsync(file);
    const entries = Object.keys(zip.files);

    onProgress?.(2, 10, 'æ­£åœ¨è§£ææ–‡æ¡£ç»“æ„...');

    // è§£æ OFD.xml
    const ofdXml = await this.parseXml(zip.file('OFD.xml'));
    const docDir = this.getDocDir(ofdXml);

    onProgress?.(4, 10, 'æ­£åœ¨è§£æé¡µé¢ç»“æ„...');

    // è§£æ Document.xml
    const docXml = await this.parseXml(zip.file(`${docDir}/Document.xml`));
    const pageCount = this.getPageCount(docXml);

    // è§£ææ¯ä¸€é¡µ
    for (let i = 0; i < pageCount; i++) {
      onProgress?.(5 + (i / pageCount) * 4, 10, `æ­£åœ¨è§£æé¡µé¢ ${i + 1}/${pageCount}...`);

      const pageEntry = `${docDir}/Pages/Page_${i}/Content.xml`;
      const pageXml = await this.parseXml(zip.file(pageEntry));

      this.pages.push({
        index: i,
        content: pageXml,
        size: this.getPageSize(pageXml),
        elements: this.parsePageElements(pageXml),
      });
    }

    onProgress?.(9, 10, 'æ­£åœ¨åŠ è½½èµ„æº...');

    // åŠ è½½èµ„æº
    await this.loadResources(zip, docDir);

    onProgress?.(10, 10, 'åŠ è½½å®Œæˆ');
  }

  private async parseXml(file: any): Promise<Document> {
    const text = await file.async('text');
    return new DOMParser().parseFromString(text, 'text/xml');
  }

  private getDocDir(ofdXml: Document): string {
    const docBody = ofdXml.getElementsByTagName('DocBody')[0];
    const docInfo = docBody?.getElementsByTagName('DocInfo')[0];
    const docID = docInfo?.getElementsByTagName('DocID')[0]?.textContent;
    return `Doc_${docID || 0}`;
  }

  private getPageCount(docXml: Document): number {
    const pages = docXml.getElementsByTagName('Page');
    return pages.length;
  }

  private getPageSize(pageXml: Document): { width: number; height: number } {
    const pageArea = pageXml.getElementsByTagName('PageArea')[0];
    const physicalBox = pageArea?.getElementsByTagName('PhysicalBox')[0]?.textContent;

    if (physicalBox) {
      const [x1, y1, x2, y2] = physicalBox.split(' ').map(Number);
      return { width: x2 - x1, height: y2 - y1 };
    }

    return { width: 210, height: 297 }; // é»˜è®¤ A4
  }
}
```

**2. é¡µé¢å…ƒç´ è§£æ**

```typescript
private parsePageElements(pageXml: Document): OFDElement[] {
  const elements: OFDElement[] = [];
  const content = pageXml.getElementsByTagName('Content')[0];

  // è§£æå›¾å±‚
  const layers = content?.getElementsByTagName('Layer');
  for (const layer of layers || []) {
    const layerElement = this.parseLayer(layer);
    elements.push(...layerElement);
  }

  return elements;
}

private parseLayer(layer: Element): OFDElement[] {
  const elements: OFDElement[] = [];
  const children = layer.children;

  for (const child of children) {
    switch (child.tagName) {
      case 'Path':
        elements.push(this.parsePath(child));
        break;
      case 'ImageObject':
        elements.push(this.parseImageObject(child));
        break;
      case 'TextObject':
        elements.push(this.parseTextObject(child));
        break;
      case 'CompositeObject':
        elements.push(this.parseCompositeObject(child));
        break;
    }
  }

  return elements;
}

private parsePath(pathEl: Element): OFDPath {
  const data = pathEl.getElementsByTagName('Data')[0]?.textContent || '';
  const fillColor = pathEl.getElementsByTagName('FillColor')[0];
  const strokeColor = pathEl.getElementsByTagName('StrokeColor')[0];

  return {
    type: 'path',
    data: this.parsePathData(data),
    fillColor: this.parseColor(fillColor),
    strokeColor: this.parseColor(strokeColor),
    strokeWidth: parseFloat(pathEl.getElementsByTagName('StrokeWidth')[0]?.textContent || '1'),
  };
}

private parseImageObject(imgEl: Element): OFDImage {
  const resourceId = imgEl.getElementsByTagName('ResourceID')[0]?.textContent;
  const clip = imgEl.getElementsByTagName('Clip')[0];
  const boundary = imgEl.getElementsByTagName('Boundary')[0]?.textContent?.split(' ').map(Number);

  return {
    type: 'image',
    resourceId,
    resource: this.resources.get(`image_${resourceId}`),
    boundary: boundary ? { x: boundary[0], y: boundary[1], width: boundary[2], height: boundary[3] } : undefined,
    clip: clip ? this.parsePathData(clip.getElementsByTagName('Data')[0]?.textContent || '') : undefined,
  };
}

private parseTextObject(textEl: Element): OFDText {
  const textCode = textEl.getElementsByTagName('TextCode')[0];
  const font = textEl.getElementsByTagName('Font')[0]?.textContent;
  const fillColor = textEl.getElementsByTagName('FillColor')[0];

  return {
    type: 'text',
    content: textCode?.textContent || '',
    fontSize: parseFloat(textEl.getElementsByTagName('Size')[0]?.textContent || '12'),
    fontId: font,
    fillColor: this.parseColor(fillColor),
    boundary: textEl.getElementsByTagName('Boundary')[0]?.textContent?.split(' ').map(Number),
  };
}
```

**3. Canvas æ¸²æŸ“**

```typescript
async renderToContainer(
  container: HTMLElement,
  pageIndex: number,
  scale: number = 1
): Promise<void> {
  const page = this.pages[pageIndex];
  if (!page) throw new Error(`é¡µé¢ ${pageIndex} ä¸å­˜åœ¨`);

  // æ¸…ç©ºå®¹å™¨
  container.innerHTML = '';

  // åˆ›å»ºé¡µé¢å®¹å™¨
  const pageDiv = document.createElement('div');
  pageDiv.id = `page-${pageIndex}`;
  pageDiv.style.cssText = `
    position: relative;
    width: ${page.size.width * scale}px;
    height: ${page.size.height * scale}px;
    background: white;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  `;

  // æ¸²æŸ“æ¯ä¸ªå…ƒç´ 
  for (const element of page.elements) {
    const elementDiv = await this.renderElement(element, scale);
    pageDiv.appendChild(elementDiv);
  }

  container.appendChild(pageDiv);
}

private async renderElement(element: OFDElement, scale: number): Promise<HTMLElement> {
  switch (element.type) {
    case 'path':
      return this.renderPath(element as OFDPath, scale);
    case 'image':
      return this.renderImage(element as OFDImage, scale);
    case 'text':
      return this.renderText(element as OFDText, scale);
    default:
      const div = document.createElement('div');
      div.textContent = `æœªçŸ¥å…ƒç´ ç±»å‹: ${element.type}`;
      return div;
  }
}

private renderPath(path: OFDPath, scale: number): HTMLElement {
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', '100%');

  const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  pathElement.setAttribute('d', this.convertPathData(path.data, scale));

  if (path.fillColor) {
    pathElement.setAttribute('fill', this.colorToCss(path.fillColor));
  }
  if (path.strokeColor) {
    pathElement.setAttribute('stroke', this.colorToCss(path.strokeColor));
    pathElement.setAttribute('stroke-width', String(path.strokeWidth * scale));
  }

  svg.appendChild(pathElement);
  return svg;
}

private renderImage(img: OFDImage, scale: number): HTMLElement {
  const div = document.createElement('div');
  div.style.position = 'absolute';
  div.style.left = `${(img.boundary?.[0] || 0) * scale}px`;
  div.style.top = `${(img.boundary?.[1] || 0) * scale}px`;
  div.style.width = `${(img.boundary?.[2] || 0) * scale}px`;
  div.style.height = `${(img.boundary?.[3] || 0) * scale}px`;
  div.style.overflow = 'hidden';

  if (img.resource) {
    const imgEl = document.createElement('img');
    imgEl.src = img.resource.dataUrl;
    imgEl.style.width = '100%';
    imgEl.style.height = '100%';
    imgEl.style.objectFit = 'contain';
    div.appendChild(imgEl);
  }

  return div;
}

private renderText(text: OFDText, scale: number): HTMLElement {
  const div = document.createElement('div');
  div.textContent = text.content;
  div.style.position = 'absolute';

  if (text.boundary) {
    div.style.left = `${text.boundary[0] * scale}px`;
    div.style.top = `${text.boundary[1] * scale}px`;
    div.style.width = `${text.boundary[2] * scale}px`;
    div.style.height = `${text.boundary[3] * scale}px`;
  }

  div.style.fontSize = `${text.fontSize * scale}px`;
  div.style.color = text.fillColor ? this.colorToCss(text.fillColor) : 'black';

  return div;
}
```

**4. è½¬æ¢ä¸ºå›¾ç‰‡**

```typescript
async convertToImage(
  options: {
    format: 'png' | 'jpeg' | 'webp';
    quality: number;
    scale: number;
    pages: 'all' | 'current' | 'custom';
    background?: string;
    customPagesInput?: string;
  },
  currentPage: number,
  onProgress?: (current: number, total: number, status: string) => void
): Promise<Blob[]> {
  const blobs: Blob[] = [];
  const pageCount = this.pages.length;

  // ç¡®å®šè¦è½¬æ¢çš„é¡µé¢
  let pagesToConvert: number[] = [];
  if (options.pages === 'all') {
    pagesToConvert = Array.from({ length: pageCount }, (_, i) => i);
  } else if (options.pages === 'current') {
    pagesToConvert = [currentPage];
  } else if (options.pages === 'custom') {
    pagesToConvert = this.parsePageRange(options.customPagesInput || '', pageCount);
  }

  // åˆ›å»ºä¸´æ—¶æ¸²æŸ“å®¹å™¨
  const container = document.createElement('div');

  for (let i = 0; i < pagesToConvert.length; i++) {
    const pageIndex = pagesToConvert[i];
    onProgress?.(i + 1, pagesToConvert.length, `æ­£åœ¨è½¬æ¢é¡µé¢ ${pageIndex + 1}`);

    // æ¸²æŸ“åˆ°å®¹å™¨
    await this.renderToContainer(container, pageIndex, options.scale);

    // è½¬æ¢ä¸º Canvas
    const canvas = await this.htmlToCanvas(container, options.background || '#ffffff');

    // å¯¼å‡ºä¸º Blob
    const blob = await new Promise<Blob | null>((resolve) => {
      canvas.toBlob(
        (b) => resolve(b),
        `image/${options.format}`,
        options.quality / 100
      );
    });

    if (blob) {
      blobs.push(blob);
    }
  }

  return blobs;
}

private async htmlToCanvas(element: HTMLElement, backgroundColor: string): Promise<HTMLCanvasElement> {
  const rect = element.getBoundingClientRect();
  const canvas = document.createElement('canvas');
  canvas.width = rect.width;
  canvas.height = rect.height;

  const ctx = canvas.getContext('2d');
  if (!ctx) throw new Error('æ— æ³•è·å– Canvas ä¸Šä¸‹æ–‡');

  // å¡«å……èƒŒæ™¯
  ctx.fillStyle = backgroundColor;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // ä½¿ç”¨ html2canvas æˆ–ç›´æ¥ç»˜åˆ¶
  // è¿™é‡Œä½¿ç”¨ DOMParser å’Œæ‰‹åŠ¨ç»˜åˆ¶çš„æ–¹å¼
  const svgData = new XMLSerializer().serializeToString(element);
  const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(svgBlob);

  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      ctx.drawImage(img, 0, 0);
      URL.revokeObjectURL(url);
      resolve(canvas);
    };
    img.onerror = reject;
    img.src = url;
  });
}
```

**5. è½¬æ¢ä¸º PDF**

```typescript
async convertToPdf(
  options: {
    pageSize: 'A4' | 'A3' | 'original';
    orientation: 'portrait' | 'landscape';
    quality: number;
    compression: boolean;
  },
  onProgress?: (current: number, total: number, status: string) => void
): Promise<Blob> {
  const { jsPDF } = await import('jspdf');
  const pdf = new jsPDF({
    orientation: options.orientation,
    unit: 'mm',
    format: options.pageSize === 'original' ? 'a4' : options.pageSize.toLowerCase(),
  });

  const container = document.createElement('div');
  const pageCount = this.pages.length;

  for (let i = 0; i < pageCount; i++) {
    onProgress?.(i + 1, pageCount, `æ­£åœ¨å¤„ç†é¡µé¢ ${i + 1}`);

    // æ¸²æŸ“é¡µé¢
    await this.renderToContainer(container, i, 2);

    // è½¬æ¢ä¸º Canvas
    const canvas = await this.htmlToCanvas(container, '#ffffff');

    // è·å–å›¾ç‰‡æ•°æ®
    const imgData = canvas.toDataURL('image/jpeg', options.quality / 100);

    // æ·»åŠ åˆ° PDF
    if (i > 0) {
      pdf.addPage();
    }

    const pageSize = pdf.internal.pageSize;
    pdf.addImage(
      imgData,
      'JPEG',
      0,
      0,
      pageSize.getWidth(),
      pageSize.getHeight()
    );
  }

  return pdf.output('blob');
}
```

**6. ç”µå­ç­¾ç« éªŒè¯**

```typescript
// utils/ofd-core/verify_signature_util.js
export const verifySignature = async (signature: SES_Signature): Promise<VerificationResult> => {
  const result: VerificationResult = {
    valid: false,
    signTime: null,
    signerName: null,
    algorithm: null,
    error: null,
  };

  try {
    // 1. è§£æç­¾ç« è¯ä¹¦
    const certInfo = await parseCertificate(signature.cert);
    result.signerName = certInfo.subject.commonName || certInfo.subject.organization;

    // 2. è·å–ç­¾ç« æ—¶é—´
    result.signTime = signature.signTime;

    // 3. è·å–ç­¾åç®—æ³•
    result.algorithm = signature.digestAlgorithm;

    // 4. è®¡ç®—åŸæ–‡ SM3 å“ˆå¸Œ
    const documentHash = await calculateSM3Hash(signature.signedData);

    // 5. ä½¿ç”¨å…¬é’¥éªŒç­¾
    const publicKey = await importSM2PublicKey(certInfo.publicKey);
    const isValid = await sm2Verify(
      signature.signatureValue,
      documentHash,
      publicKey,
      'sm2'
    );

    result.valid = isValid;

    // 6. éªŒè¯è¯ä¹¦æœ‰æ•ˆæœŸ
    const now = new Date();
    if (now < certInfo.notBefore || now > certInfo.notAfter) {
      result.valid = false;
      result.error = 'è¯ä¹¦å·²è¿‡æœŸæˆ–å°šæœªç”Ÿæ•ˆ';
    }

    // 7. éªŒè¯è¯ä¹¦é“¾ï¼ˆç®€åŒ–ç‰ˆï¼‰
    const issuerValid = await verifyCertificateChain(certInfo);
    if (!issuerValid) {
      result.valid = false;
      result.error = 'è¯ä¹¦é“¾éªŒè¯å¤±è´¥';
    }
  } catch (error) {
    result.error = error instanceof Error ? error.message : 'éªŒç­¾å¤±è´¥';
  }

  return result;
};

// SM2 ç­¾åéªŒè¯
const sm2Verify = async (
  signature: string,
  hash: string,
  publicKey: CryptoKey,
  algorithm: string
): Promise<boolean> => {
  const encoder = new TextEncoder();
  const data = encoder.encode(hash);
  const signatureBytes = hexToBytes(signature);

  try {
    const isValid = await crypto.subtle.verify(
      { name: algorithm, hash: 'SM3' },
      publicKey,
      signatureBytes,
      data
    );
    return isValid;
  } catch {
    return false;
  }
};
```

---

## é¡¹ç›®ç»“æ„

```
image/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/           # Vue 3 ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ FileUpload.vue    # æ–‡ä»¶ä¸Šä¼ ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ FileList.vue      # æ–‡ä»¶åˆ—è¡¨ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ FormatSelector.vue # æ ¼å¼é€‰æ‹©å™¨
â”‚   â”‚   â”œâ”€â”€ AdvancedSettings.vue # é«˜çº§è®¾ç½®é¢æ¿
â”‚   â”‚   â”œâ”€â”€ ImagePreview.vue  # å›¾ç‰‡é¢„è§ˆç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ ProgressBar.vue   # è¿›åº¦æ¡ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ OfdProcessor.vue  # OFD å¤„ç†å™¨
â”‚   â”‚   â””â”€â”€ OfdPreview.vue    # OFD é¢„è§ˆç»„ä»¶
â”‚   â”œâ”€â”€ stores/               # çŠ¶æ€ç®¡ç†
â”‚   â”‚   â””â”€â”€ imageStore.ts     # å›¾ç‰‡çŠ¶æ€å­˜å‚¨ (Vue Reactive)
â”‚   â”œâ”€â”€ utils/                # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ imageConverter.ts # å›¾ç‰‡è½¬æ¢æ ¸å¿ƒé€»è¾‘
â”‚   â”‚   â”œâ”€â”€ ofdConverter.ts   # OFD è½¬æ¢å™¨
â”‚   â”‚   â”œâ”€â”€ download.ts       # ä¸‹è½½å¤„ç†
â”‚   â”‚   â”œâ”€â”€ validator.ts      # æ–‡ä»¶éªŒè¯
â”‚   â”‚   â”œâ”€â”€ security.ts       # å®‰å…¨ç›¸å…³
â”‚   â”‚   â”œâ”€â”€ pwa.ts            # PWA é…ç½®
â”‚   â”‚   â””â”€â”€ ofd-core/         # OFD è§£ææ ¸å¿ƒ
â”‚   â”‚       â”œâ”€â”€ ofd.js        # OFD è§£æå…¥å£
â”‚   â”‚       â”œâ”€â”€ ofd_parser.js # OFD XML è§£æ
â”‚   â”‚       â”œâ”€â”€ ofd_render.js # OFD æ¸²æŸ“å¼•æ“
â”‚   â”‚       â”œâ”€â”€ sm3.js        # SM3 å“ˆå¸Œç®—æ³•
â”‚   â”‚       â”œâ”€â”€ ses_signature_parser.js # SES ç­¾ç« è§£æ
â”‚   â”‚       â””â”€â”€ verify_signature_util.js # ç­¾ç« éªŒè¯
â”‚   â”œâ”€â”€ ofd-export/           # OFD å¯¼å‡ºæ¨¡å—
â”‚   â”‚   â””â”€â”€ core/             # å¯¼å‡ºæ ¸å¿ƒå®ç°
â”‚   â”œâ”€â”€ types/                # TypeScript ç±»å‹å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ index.ts          # ä¸»ç±»å‹æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ ofd.d.ts          # OFD ç±»å‹
â”‚   â”‚   â””â”€â”€ pica.d.ts         # Pica ç±»å‹
â”‚   â”œâ”€â”€ App.vue               # ä¸»åº”ç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ main.ts               # å…¥å£æ–‡ä»¶
â”‚   â””â”€â”€ index.css             # å…¨å±€æ ·å¼
â”œâ”€â”€ public/                   # é™æ€èµ„æº
â”œâ”€â”€ vite.config.ts            # Vite é…ç½®
â”œâ”€â”€ tailwind.config.js        # Tailwind é…ç½®
â”œâ”€â”€ tsconfig.json             # TypeScript é…ç½®
â””â”€â”€ package.json              # é¡¹ç›®ä¾èµ–
```

---

## å¿«é€Ÿå¼€å§‹

### ç¯å¢ƒè¦æ±‚

- Node.js 18+
- pnpmï¼ˆæ¨èï¼‰æˆ– npm

### å®‰è£…ä¾èµ–

```bash
pnpm install
# æˆ–
npm install
```

### å¯åŠ¨å¼€å‘æœåŠ¡å™¨

```bash
pnpm dev
```

### æ„å»ºç”Ÿäº§ç‰ˆæœ¬

```bash
pnpm build
```

### é¢„è§ˆç”Ÿäº§æ„å»º

```bash
pnpm preview
```

---

## éƒ¨ç½²æ–¹æ¡ˆ

### Vercel éƒ¨ç½²ï¼ˆæ¨èï¼‰

```bash
# å®‰è£… Vercel CLI
npm i -g vercel

# éƒ¨ç½²
vercel
```

æˆ–é€šè¿‡ GitHub ç›´æ¥å¯¼å…¥ï¼š
1. è®¿é—® [Vercel](https://vercel.com)
2. ç‚¹å‡» "Add New Project"
3. å¯¼å…¥ GitHub ä»“åº“

### Netlify éƒ¨ç½²

```bash
npm i -g netlify-cli
netlify deploy --prod
```

### GitHub Pages éƒ¨ç½²

ä¿®æ”¹ `vite.config.ts` ä¸­çš„ base è·¯å¾„ï¼š

```typescript
export default defineConfig({
  base: '/your-repo-name/',
  // ...
})
```

æ„å»ºéƒ¨ç½²ï¼š

```bash
pnpm build
npx gh-pages -d dist
```

### Docker éƒ¨ç½²

```dockerfile
# Dockerfile
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN pnpm install
COPY . .
RUN pnpm build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

```bash
docker build -t image-converter .
docker run -p 80:80 image-converter
```

---

## æµè§ˆå™¨æ”¯æŒ

| æµè§ˆå™¨ | ç‰ˆæœ¬ | çŠ¶æ€ |
|--------|------|------|
| Chrome | 90+ | å®Œå…¨æ”¯æŒ |
| Firefox | 88+ | å®Œå…¨æ”¯æŒ |
| Safari | 15+ | å®Œå…¨æ”¯æŒ |
| Edge | 90+ | å®Œå…¨æ”¯æŒ |

## æ€§èƒ½ä¼˜åŒ–

- **ä»£ç åˆ†å‰²**: æŒ‰è·¯ç”±/ç»„ä»¶å¼‚æ­¥åŠ è½½
- **å›¾ç‰‡ç¼©æ”¾**: ä½¿ç”¨ Pica åº“å®ç°é«˜è´¨é‡ Lanczos ç¼©æ”¾
- **æ ¼å¼æ”¯æŒ**: åŸç”Ÿæ ¼å¼ä¼˜å…ˆï¼Œå¤æ‚æ ¼å¼é™çº§å¤„ç†
- **Vue å“åº”å¼ä¼˜åŒ–**: ä½¿ç”¨ `toRef` é¿å…ä¸å¿…è¦çš„å“åº”å¼å¼€é”€
- **æ¸²æŸ“ä¼˜åŒ–**: OFD æ¸²æŸ“ä½¿ç”¨ `requestAnimationFrame` å’Œ `nextTick`

## å®‰å…¨ç‰¹æ€§

- **æœ¬åœ°å¤„ç†**: æ‰€æœ‰æ–‡ä»¶å¤„ç†åœ¨æµè§ˆå™¨å®Œæˆ
- **æ— æœåŠ¡ç«¯**: ä¸å‘ä»»ä½•æœåŠ¡å™¨ä¼ è¾“æ–‡ä»¶
- **æ²™ç®±éš”ç¦»**: ä½¿ç”¨ iframe éš”ç¦»ç¬¬ä¸‰æ–¹å†…å®¹
- **è¾“å…¥éªŒè¯**: ä¸¥æ ¼çš„æ–‡ä»¶ç±»å‹å’Œå¤§å°éªŒè¯

## è´¡çŒ®æŒ‡å—

æ¬¢è¿æäº¤ Issue å’Œ Pull Requestï¼

1. Fork æœ¬ä»“åº“
2. åˆ›å»ºåŠŸèƒ½åˆ†æ”¯ (`git checkout -b feature/AmazingFeature`)
3. æäº¤æ›´æ”¹ (`git commit -m 'Add some AmazingFeature'`)
4. æ¨é€åˆ°åˆ†æ”¯ (`git push origin feature/AmazingFeature`)
5. æ‰“å¼€ Pull Request

## è®¸å¯è¯

æœ¬é¡¹ç›®é‡‡ç”¨ MIT Licenseã€‚

## è‡´è°¢

- [Vue.js](https://vuejs.org/) - æ¸è¿›å¼ JavaScript æ¡†æ¶
- [Pica](https://nodeca.github.io/pica/) - é«˜è´¨é‡å›¾ç‰‡ç¼©æ”¾åº“
- [jsPDF](https://github.com/parallax/jsPDF) - PDF ç”Ÿæˆåº“
- [Tailwind CSS](https://tailwindcss.com/) - å®ç”¨ä¼˜å…ˆçš„ CSS æ¡†æ¶
- [JSZip](https://stuk.github.io/jszip/) - ZIP æ–‡ä»¶å¤„ç†
- [Vite](https://vitejs.dev/) - ä¸‹ä¸€ä»£å‰ç«¯æ„å»ºå·¥å…·

---

**æ³¨æ„**: æœ¬é¡¹ç›®æ‰€æœ‰å›¾ç‰‡å’Œæ–‡æ¡£å¤„ç†å‡åœ¨æµè§ˆå™¨æœ¬åœ°å®Œæˆï¼Œä¸ä¼šå°†ä»»ä½•æ–‡ä»¶ä¸Šä¼ åˆ°æœåŠ¡å™¨ã€‚
